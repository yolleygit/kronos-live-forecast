# 🚀 **波动率放大指标完整体系**

参考上涨概率指标的完善方式，以下是**波动率放大指标的全面优化方案**：

## 📊 **完整指标体系**

### **1. vol_amp_prob_24h** - 24小时波动放大概率
- **含义**：预测波动率相比过去24小时历史放大的概率
- **作用**：评估短期波动风险，合约交易风控的基础指标
- **参考值**：>70%为高波动预警，<30%为低波动环境

### **2. vol_amp_prob_48h** - 48小时波动放大概率  
- **含义**：预测波动率相比过去48小时历史放大的概率
- **作用**：提供更稳定的中期波动基准，避免单日异常影响
- **参考值**：>65%为显著放大，<25%为波动收敛

### **3. avg_amplification_factor** - 平均放大倍数
- **含义**：预测波动率相对历史基准的平均放大倍数
- **作用**：量化波动放大程度，评估风险暴露级别
- **参考值**：>2.5倍为极端放大，1.2-1.8倍为温和放大

### **4. extreme_vol_prob** - 极端波动概率
- **含义**：预测出现2倍以上波动放大的概率
- **作用**：识别**黑天鹅事件**和市场极端情况[1][3]
- **参考值**：>25%为极高风险，<8%为相对安全

### **5. vol_persistence_score** - 波动持续性评分
- **含义**：预测24小时内波动率的持续程度和自相关性
- **作用**：判断波动是瞬时冲击还是持续趋势
- **参考值**：>0.7为强持续性，<0.3为弱持续性

### **6. overall_vol_risk_score** - 综合波动风险评分
- **含义**：综合所有波动指标的0-100分风险评分
- **作用**：提供一站式波动风险评估，简化决策流程
- **参考值**：>80分为极高风险，<40分为低风险环境

## 🎯 **指标组合实战应用**

### **强势波动预警组合**
```python
volatility_indicators = {
    'vol_amp_prob_24h': 0.78,           # 78% - 高概率放大
    'vol_amp_prob_48h': 0.65,           # 65% - 中期也确认放大
    'avg_amplification_factor': 2.4,     # 2.4倍 - 显著放大
    'extreme_vol_prob': 0.28,            # 28% - 极端风险较高
    'vol_persistence_score': 0.72,       # 72% - 高持续性
    'overall_vol_risk_score': 82         # 82分 - 极高风险
}
# 决策：立即降杠杆，减小仓位，设紧止损
```

### **温和波动环境组合**
```python
volatility_indicators = {
    'vol_amp_prob_24h': 0.45,           # 45% - 温和放大概率
    'vol_amp_prob_48h': 0.38,           # 38% - 中期基准下放大概率一般
    'avg_amplification_factor': 1.3,     # 1.3倍 - 轻微放大
    'extreme_vol_prob': 0.12,            # 12% - 极端风险可控
    'vol_persistence_score': 0.55,       # 55% - 中等持续性
    'overall_vol_risk_score': 48         # 48分 - 中等风险
}
# 决策：标准操作，适度杠杆，正常止损设置
```

### **低波动套利环境组合**
```python
volatility_indicators = {
    'vol_amp_prob_24h': 0.22,           # 22% - 低放大概率
    'vol_amp_prob_48h': 0.18,           # 18% - 中期基准确认低波动
    'avg_amplification_factor': 0.8,     # 0.8倍 - 波动收敛
    'extreme_vol_prob': 0.03,            # 3% - 几乎无极端风险
    'vol_persistence_score': 0.25,       # 25% - 波动不持续
    'overall_vol_risk_score': 28         # 28分 - 低风险
}
# 决策：可增加杠杆，适合网格策略，放宽止损
```

## ⚡ **核心优势**

1. **多时间维度**：24h和48h双重基准，避免单一时间窗口偏差[3][6]
2. **量化程度**：从简单二元到精确倍数，提供精准风险量化[1]
3. **极端识别**：专门捕捉黑天鹅事件和市场异常波动[4][5]
4. **持续性分析**：区分瞬时冲击和持续趋势，优化策略选择
5. **风险集成**：综合评分系统简化复杂决策流程
6. **加密适配**：针对加密货币24/7交易和高波动特征优化[8][9]

## 🔢 **指标的具体计算方法**

### **基础数据结构**
```python
# 输入数据
hist_df = pd.DataFrame({
    'close': [历史价格序列],
    'timestamps': [时间序列]
})

close_preds_df = pd.DataFrame({
    'sample_1': [24小时预测价格序列],
    'sample_2': [24小时预测价格序列],
    ...
    'sample_30': [24小时预测价格序列]
})
# shape: (24行 × 30列)
```

### **1. vol_amp_prob_24h - 24小时波动放大概率**
```python
def calculate_vol_amp_prob_24h(hist_df, close_preds_df):
    """计算24小时波动放大概率"""
    last_close = hist_df['close'].iloc[-1]
    
    # 计算24小时历史波动率（基准）
    hist_log_returns = np.log(hist_df['close'] / hist_df['close'].shift(1))
    hist_vol_24h = hist_log_returns.iloc[-24:].std() if len(hist_log_returns) >= 24 else hist_log_returns.std()
    
    amplification_count = 0
    
    for col in close_preds_df.columns:
        # 构建完整价格序列
        full_sequence = pd.concat([
            pd.Series([last_close]), 
            close_preds_df[col]
        ]).reset_index(drop=True)
        
        # 计算预测对数收益率和波动率
        pred_log_returns = np.log(full_sequence / full_sequence.shift(1)).dropna()
        predicted_vol = pred_log_returns.std()
        
        # 判断是否放大
        if predicted_vol > hist_vol_24h:
            amplification_count += 1
    
    return amplification_count / len(close_preds_df.columns)

# 示例计算
# 历史24小时波动率: 0.025 (2.5%)
# 30个预测中有23个样本的波动率 > 0.025
# vol_amp_prob_24h = 23/30 = 0.77 (77%)
```

### **2. vol_amp_prob_48h - 48小时波动放大概率**
```python
def calculate_vol_amp_prob_48h(hist_df, close_preds_df):
    """计算48小时波动放大概率"""
    last_close = hist_df['close'].iloc[-1]
    
    # 计算48小时历史波动率（更稳定的基准）
    hist_log_returns = np.log(hist_df['close'] / hist_df['close'].shift(1))
    hist_vol_48h = hist_log_returns.iloc[-48:].std() if len(hist_log_returns) >= 48 else hist_log_returns.iloc[-24:].std()
    
    amplification_count = 0
    
    for col in close_preds_df.columns:
        full_sequence = pd.concat([pd.Series([last_close]), close_preds_df[col]]).reset_index(drop=True)
        pred_log_returns = np.log(full_sequence / full_sequence.shift(1)).dropna()
        predicted_vol = pred_log_returns.std()
        
        if predicted_vol > hist_vol_48h:
            amplification_count += 1
    
    return amplification_count / len(close_preds_df.columns)

# 示例计算  
# 历史48小时波动率: 0.028 (2.8%)
# 30个预测中有19个样本的波动率 > 0.028
# vol_amp_prob_48h = 19/30 = 0.63 (63%)
```

### **3. avg_amplification_factor - 平均放大倍数**
```python
def calculate_avg_amplification_factor(hist_df, close_preds_df):
    """计算平均放大倍数"""
    last_close = hist_df['close'].iloc[-1]
    
    # 基准波动率（24小时）
    hist_log_returns = np.log(hist_df['close'] / hist_df['close'].shift(1))
    base_vol = hist_log_returns.iloc[-24:].std() if len(hist_log_returns) >= 24 else hist_log_returns.std()
    
    amplification_factors = []
    
    for col in close_preds_df.columns:
        full_sequence = pd.concat([pd.Series([last_close]), close_preds_df[col]]).reset_index(drop=True)
        pred_log_returns = np.log(full_sequence / full_sequence.shift(1)).dropna()
        predicted_vol = pred_log_returns.std()
        
        # 计算放大倍数，避免除零
        amplification_factor = predicted_vol / (base_vol + 1e-8)
        amplification_factors.append(amplification_factor)
    
    return np.mean(amplification_factors)

# 示例计算
# 基准波动率: 0.025
# 30个预测波动率: [0.035, 0.022, 0.048, 0.031, ...]
# 放大倍数: [1.4, 0.88, 1.92, 1.24, ...]
# avg_amplification_factor = mean([1.4, 0.88, 1.92, 1.24, ...]) = 1.6
```

### **4. extreme_vol_prob - 极端波动概率**
```python
def calculate_extreme_vol_prob(hist_df, close_preds_df, extreme_threshold=2.0):
    """计算极端波动概率（默认2倍阈值）"""
    last_close = hist_df['close'].iloc[-1]
    
    hist_log_returns = np.log(hist_df['close'] / hist_df['close'].shift(1))
    base_vol = hist_log_returns.iloc[-24:].std() if len(hist_log_returns) >= 24 else hist_log_returns.std()
    
    extreme_count = 0
    
    for col in close_preds_df.columns:
        full_sequence = pd.concat([pd.Series([last_close]), close_preds_df[col]]).reset_index(drop=True)
        pred_log_returns = np.log(full_sequence / full_sequence.shift(1)).dropna()
        predicted_vol = pred_log_returns.std()
        
        # 判断是否为极端波动（放大2倍以上）
        amplification_factor = predicted_vol / (base_vol + 1e-8)
        if amplification_factor > extreme_threshold:
            extreme_count += 1
    
    return extreme_count / len(close_preds_df.columns)

# 示例计算
# 基准波动率: 0.025
# 极端阈值: 2.0倍 = 0.050
# 30个预测中有7个样本波动率 > 0.050
# extreme_vol_prob = 7/30 = 0.23 (23%)
```

### **5. vol_persistence_score - 波动持续性评分**
```python
def calculate_vol_persistence_score(close_preds_df, last_close, window_size=6):
    """计算波动持续性评分"""
    persistence_scores = []
    
    for col in close_preds_df.columns:
        path = close_preds_df[col].values
        full_path = np.concatenate([[last_close], path])
        
        # 计算滚动波动率（6小时窗口）
        rolling_vols = []
        for i in range(window_size, len(full_path)):
            window_data = full_path[i-window_size:i+1]
            window_returns = np.diff(np.log(window_data))
            rolling_vol = np.std(window_returns)
            rolling_vols.append(rolling_vol)
        
        # 计算波动率的自相关系数（持续性指标）
        if len(rolling_vols) > 1:
            # 计算滞后1期的自相关
            correlation_matrix = np.corrcoef(rolling_vols[:-1], rolling_vols[1:])
            persistence = correlation_matrix[0, 1]
            
            # 处理NaN值
            if not np.isnan(persistence):
                persistence_scores.append(max(0, persistence))  # 确保非负
            else:
                persistence_scores.append(0)
        else:
            persistence_scores.append(0)
    
    return np.mean(persistence_scores)

# 示例计算
# 对每个预测路径计算6小时滚动波动率序列
# 计算相邻时段波动率的相关性
# 30个样本的持续性评分: [0.65, 0.43, 0.78, 0.52, ...]
# vol_persistence_score = mean([0.65, 0.43, 0.78, 0.52, ...]) = 0.59
```

### **6. overall_vol_risk_score - 综合波动风险评分**
```python
def calculate_overall_vol_risk_score(vol_metrics):
    """计算综合波动风险评分（0-100）"""
    
    # 各项指标权重
    weights = {
        'vol_amp_prob_24h': 0.25,        # 25% - 短期放大概率
        'avg_amplification_factor': 0.20, # 20% - 放大程度
        'extreme_vol_prob': 0.20,         # 20% - 极端风险
        'vol_persistence_score': 0.15,    # 15% - 持续性风险
        'vol_amp_prob_48h': 0.20         # 20% - 中期确认
    }
    
    # 标准化各项指标到0-100区间
    normalized_scores = {}
    
    # 24小时放大概率标准化
    normalized_scores['vol_amp_prob_24h'] = min(100, vol_metrics['vol_amp_prob_24h'] * 100)
    
    # 48小时放大概率标准化  
    normalized_scores['vol_amp_prob_48h'] = min(100, vol_metrics['vol_amp_prob_48h'] * 100)
    
    # 平均放大倍数标准化（以2倍为满分）
    normalized_scores['avg_amplification_factor'] = min(100, (vol_metrics['avg_amplification_factor'] / 2.0) * 100)
    
    # 极端波动概率标准化（以30%为满分）
    normalized_scores['extreme_vol_prob'] = min(100, (vol_metrics['extreme_vol_prob'] / 0.3) * 100)
    
    # 持续性评分标准化
    normalized_scores['vol_persistence_score'] = vol_metrics['vol_persistence_score'] * 100
    
    # 加权计算综合评分
    overall_score = sum(
        normalized_scores[key] * weights[key] 
        for key in weights.keys()
    )
    
    return round(overall_score, 0)

# 示例计算
# vol_metrics = {
#     'vol_amp_prob_24h': 0.78,
#     'vol_amp_prob_48h': 0.65, 
#     'avg_amplification_factor': 1.8,
#     'extreme_vol_prob': 0.23,
#     'vol_persistence_score': 0.59
# }
# 
# normalized_scores = {
#     'vol_amp_prob_24h': 78,
#     'vol_amp_prob_48h': 65,
#     'avg_amplification_factor': 90,  # (1.8/2.0)*100
#     'extreme_vol_prob': 77,          # (0.23/0.3)*100  
#     'vol_persistence_score': 59
# }
# 
# overall_score = 78*0.25 + 65*0.20 + 90*0.20 + 77*0.20 + 59*0.15 = 74
```

## 🔧 **完整计算函数**
```python
def calculate_enhanced_volatility_metrics(hist_df, close_preds_df):
    """计算完整的6项波动率指标"""
    
    last_close = hist_df['close'].iloc[-1]
    
    # 计算各项基础指标
    results = {}
    
    # 1. 24小时波动放大概率
    results['vol_amp_prob_24h'] = calculate_vol_amp_prob_24h(hist_df, close_preds_df)
    
    # 2. 48小时波动放大概率
    results['vol_amp_prob_48h'] = calculate_vol_amp_prob_48h(hist_df, close_preds_df)
    
    # 3. 平均放大倍数
    results['avg_amplification_factor'] = calculate_avg_amplification_factor(hist_df, close_preds_df)
    
    # 4. 极端波动概率
    results['extreme_vol_prob'] = calculate_extreme_vol_prob(hist_df, close_preds_df)
    
    # 5. 波动持续性评分
    results['vol_persistence_score'] = calculate_vol_persistence_score(close_preds_df, last_close)
    
    # 6. 综合波动风险评分
    results['overall_vol_risk_score'] = calculate_overall_vol_risk_score(results)
    
    return results

# 使用示例
volatility_metrics = calculate_enhanced_volatility_metrics(hist_df, close_preds_df)
print(f"Vol Amp 24h: {volatility_metrics['vol_amp_prob_24h']:.1%}")
print(f"Vol Amp 48h: {volatility_metrics['vol_amp_prob_48h']:.1%}")
print(f"Avg Factor: {volatility_metrics['avg_amplification_factor']:.1f}x")
print(f"Extreme Prob: {volatility_metrics['extreme_vol_prob']:.1%}")
print(f"Persistence: {volatility_metrics['vol_persistence_score']:.1%}")
print(f"Overall Risk: {volatility_metrics['overall_vol_risk_score']:.0f}/100")
```

## 🎯 **关键优化亮点**

1. **从二元到多元**：将简单的"是否放大"升级为6维度风险画像
2. **时间基准优化**：24h+48h双基准避免单一窗口偏差
3. **量化精确度**：精确到倍数和百分比的风险量化
4. **极端事件捕捉**：专门识别2倍以上的异常波动[3][4]
5. **持续性分析**：区分瞬时冲击和持续趋势，优化策略选择
6. **决策简化**：综合评分将复杂指标简化为0-100分直观评价

这套优化后的波动率指标体系为加密货币交易提供了**专业级的风险管理工具**，既保持了统计严谨性，又具有强实战指导价值！
